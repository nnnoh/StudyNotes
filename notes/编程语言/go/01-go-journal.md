## 语法

#### 编译

- 编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字`break`、`continue`、`fallthrough`或`return`中的一个、运算符和分隔符`++`、`--`、`)`、`]`或`}`中的一个）。举个例子，函数的左括号`{`必须和`func`函数声明在同一行上，且位于末尾，不能独占一行，而在表达式`x + y`中，可在`+`后换行，不能在`+`前换行（译注：以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）。

  函数的右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。

- Go语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。


### 程序结构

- 变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的*零值*（zero value），数值类型是0，字符串类型是空字符串""。接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是`nil`。

- `i--`是语句，而不像C系的其它语言那样是表达式。所以`j = i++`非法，而且`++`和`--`都只能放在变量名后面，因此`--i`也非法。

- 变量定义与初始化

  `var 变量名字 类型 = 表达式`

  其中“*类型*”或“*= 表达式*”两个部分可以省略其中的一个。

  如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。

  如果初始化表达式被省略，那么将用零值初始化该变量。 

  数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

  ```go
  var i, j, k int                 // int, int, int
  var b, f, s = true, 2.3, "four" // bool, float64, string
  ```

- 符号`:=`是**短变量声明**（short variable declaration），在函数内部用于声明和初始化局部变量。它以`名字 := 表达式`形式声明变量，变量的类型根据表达式来自动推导。

  因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。**var**形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

  简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。

  简短变量声明语句只有对已经在**同级**词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

  注意，循环变量的作用域和循环体内变量的作用域不同。

  ```go
  	for i := 0; i < 10; i++ {
          i := 9
  		fmt.Println(i) // 执行十次
  	}
  ```

- `空标识符`（blank identifier），即`_`（也就是下划线）。空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。

- map查找、类型断言或通道接收出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功。

  对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）。

- 如果一个名字是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。

- 新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是**不兼容的**。

  ```Go
  type 类型名字 底层类型
  ```

  类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。

  底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。但注意不同类型即使底层类型相同也是**不兼容的**，无法比较进行比较和运算。（类型可以和其底层类型比较，前提是底层类型是基础数据结构）

- 对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如`(*int)(0)`）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。

  数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的，这类转换可能改变值的表现。

  在任何情况下，运行时不会发生转换失败的错误（译注: 错误只会发生在编译阶段）。
  
- Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。

- bool、byte、error、true、iota等并不是关键字，在Go中它们被称为**预定义标识符**。这些标识符拥有**universe block作用域**。

  Go语言的关键字是保留的，我们无法将其用于规范之外的其他场合，比如作为变量的标识符。但是预定义标识符不是关键字，我们可以override它们。

- Go中的内建函数仅仅是一个标识符，在Go源码编译期间，Go编译器遇到内建函数标识符时会将其替换为若干runtime的调用。


### 基础数据类型

- 通常`fmt.Printf`格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的`[1]`副词告诉Printf函数再次使用第一个操作数。

  %后的`#`副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。

  字符使用`%c`参数打印，或者是用`%q`参数打印带单引号的字符。

  `% x`参数用于在每个十六进制数字前插入一个空格。

  `%T`参数打印类型信息。

  `%*s`中的`*`会在字符串之前填充一些空格。

  [Go语言基础--Printf格式化输出、Scanf格式化输入详解_一只IT小小鸟-CSDN博客](https://blog.csdn.net/qq_34777600/article/details/81266453)

- **布尔值**并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换

- 只有常量可以是无类型的。通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。

- 类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的。

#### 字符串

- **字符**只是整数的特殊用例，用`''`单引号包括。`byte` 类型是 `uint8` 的别名。

  对于只占用 1 个字节的传统 ASCII 编码的字符来说，使用 `byte` 存储即可。

  Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码，使用 `runes`类型，并在内存中使用 int 来表示，通常为 `int32`。

- `string` 类型的零值为长度为零的字符串，即空字符串 `""`。

- **字符串拼接**可使用 `[]byte` 切片的 `append`，如 `byteSlice = append(byteSlice, strconv.Itoa(x)...)`，最后 `string(byteSlice)` 转换成字符串。

  - `strings.Builder` 内部就是维护了一个 `buf []byte`。

- **文本字符串**通常被解释为采用UTF8编码的Unicode码点（rune）序列。（Go语言源文件总是用UTF8编码，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型））

  `string`类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。前者可以由一个以`rune`为元素类型的切片来表示，而后者则可以由一个以`byte`为元素类型的切片代表。

  ```go
  byteArr := []byte(str)
  runeArr := []rune(str)
  ```

- 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变。因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的

  ```Go
  s := "left foot"
  t := s
  s += ", right foot"
  fmt.Println(s) // "left foot, right foot"
  fmt.Println(t) // "left foot"
  ```

- 一个原生的字符串面值形式是&#96;...&#96;​，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。

  在原生字符串面值内部是无法直接写&#96;字符的，可以用八进制或十六进制转义或+"&#96;"连接字符串常量完成。

  唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）。

  原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。

- 第 i 个字节并不一定是字符串的第 i 个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。

  `for range`语句会自动隐式解码UTF8字符串，逐一地迭代出字符串值里的每个 Unicode 字符。但是，相邻的 Unicode 字符的索引值并不一定是连续的。这取决于前一个 Unicode 字符是否为单字节字符。

  或者我们可以直接调用 `utf8.RuneCountInString(s)` 函数。

##### strings.Builder

`strings.Builder`类型的值的优势有：

- 已存在的内容不可变，但可以拼接更多的内容；
- 减少了内存分配和内容拷贝的次数；
- 可将内容重置，可重用值。

`string`类型的值是不可变的。只能基于原字符串进行裁剪、拼接等操作，从而生成一个新的字符串。裁剪操作可以使用切片表达式，而拼接操作可以用操作符`+`实现。

与`string`值相比，`strings.Builder`值的优势其实主要体现在字符串拼接方面。`strings.Builder `值中有一个用于承载内容的容器。它是一个以`byte`为元素类型的切片。和 string 一样，通过一个`unsafe.Pointer`类型的字段来持有那个指向了底层字节数组的指针值的。

`strings.Builder `通过调用`Write`等方法把新的内容拼接到已存在的内容的尾部。这时，如有必要，`strings.Builder `值会自动地对自身的内容容器进行扩容。这里的自动扩容策略与切片的扩容策略一致。

`strings.Builder `值是可以被重用的。通过调用它的`Reset`方法，我们可以让`strings.Builder `值重新回到零值状态，就像它从未被使用过那样，原内容会被垃圾回收。

`strings.Builder`类型约束：

- 在已被真正使用后就不可再被复制；
- 由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题。

```go
var builder1 strings.Builder
builder1.Grow(1)
builder3 := builder1
//builder3.Grow(1) // 这里会引发 panic。
```

目的是避免了多个同源的`Builder`值在拼接内容时可能产生的冲突问题。

虽然已使用的`Builder`值不能再被复制，但是它的指针值却可以。`Builder`值被多方同时操作，容易引发 panic，最好的做法是绝不共享`Builder`值以及它的指针值。

```go
f2 := func(bp *strings.Builder) {
    // 这里虽然不会引发 panic，但不是并发安全的。
    (*bp).Grow(1) 
    builder4 := *bp
    //builder4.Grow(1) // 这里会引发 panic。
    _ = builder4
}
f2(&builder1)

```

##### strings.Reader

`strings.Reader`类型是为了高效读取字符串而存在的。

在读取的过程中，`Reader`值会保存已读取的字节的计数。`Reader`实现高效读取的关键就在于它内部的已读计数。计数的值就代表着下一次读取的起始索引位置。

`Len`方法返回的是内容容器中未被读取部分的长度，而不是其中已存内容的总长度。

已读计数是字符串切片，读取回退和位置设定时的重要依据，可以通过该值的`Len`方法和`Size`把它计算出来。

```go
readingIndex := reader1.Size() - int64(reader1.Len()) // 计算出的已读计数。
```

- `ReadByte`方法会在读取成功后将这个计数的值加`1`。
- `ReadRune`方法在读取成功之后，会把被读取的字符所占用的字节数作为计数的增量。
- `ReadAt`方法算是一个例外。它既不会依据已读计数进行读取，也不会在读取后更新它。正因为如此，这个方法可以自由地读取其所属的`Reader`值中的任何内容。
- `Seek`方法会更新已读计数。主要作用正是设定下一次读取的起始索引位置。
  - 把常量`io.SeekCurrent`的值作为第二个参数值传给该方法，那么它还会依据当前的已读计数，以及第一个参数offset的值来计算新的计数值。

##### bytes包

`bytes`包面对的则主要是字节和字节切片。

`bytes.Buffer`是集读、写功能于一身的数据类型，类型的用途主要是作为字节序列的缓冲区。

在内部，`bytes.Buffer`类型同样是使用字节切片作为内容容器的。

与`strings.Reader`类型类似，`bytes.Buffer`有一个`int`类型的字段，用于代表已读字节的计数，可以简称为**已读计数**。`Len`方法返回的也是内容容器中未被读取部分的长度。

`bytes.Buffer`类型没有获取内容总长度的方法。其`Cap`方法提供的是内容容器的容量，也不是内容长度，因此很难估算出`Buffer`值的已读计数。

在扩容的时候，方法会在必要时，依据已读计数找到未读部分，并把其中的内容拷贝到扩容后内容容器的头部位置。把已读计数的值置为`0`，以表示下一次读取需要从内容容器的第一个字节开始。

#### 切片（slice）

- slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。

- 和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较。

- 内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。

- 如果**切片**操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大。但直接访问超过len(s)位置的值会报错，可通过切片操作扩展len。

  ```Go
  make([]T, len)
  make([]T, len, cap) // same as make([]T, cap)[:len] 额外的元素是留给未来的增长用的。
  ```

- 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。

- 因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。

#### 常量

常量使用关键字 `const` 定义，用于存储不会改变的数据。

存储在常量中的数据类型**只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型**。

- 显式类型定义： `const b string = "abc"`

- 隐式类型定义： `const b = "abc"`

- 并行赋值：`const beef, two, c = "eat", 2, "veg"`

- 枚举：

  ```go
  const (
      a = iota // 0
      b = iota // 1
      c = iota // 2
  )
  ```

常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。

- 正确的做法：`const c1 = 2/3`
- 错误的做法：`const c2 = getNumber()` // 引发构建错误: `getNumber() used as value`

**因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。**

数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：

```go
// 反斜杠 \ 可以在常量表达式中作为多行的连接符使用
const Ln2 = 0.693147180559945309417232121458\
            176568075500134360255254120680009
const Log2E = 1/Ln2 // this is a precise reciprocal
const Billion = 1e9 // float constant
const hardEight = (1 << 100) >> 97
```

与各种类型的数字型变量相比，你无需担心常量之间的类型转换问题，因为它们都是非常理想的数字。

不过需要注意的是，当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。

##### iota

Go的`iota`标识符用于`const`声明中，以简化递增数字的定义。因为它可以在表达式中使用，所以它提供了除简单枚举之外的一般性。

在每遇到一个新的常量块或单个常量声明时， `iota` 都会重置为 0。

```go
// 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式
const (
    a = iota  // a = 0
    b         // b = 1
    c         // c = 2
    d = 5     // d = 5   
    e         // e = 5
)

// 使用 iota 结合 位运算 表示资源状态的使用案例
const (
    _           = iota             // 使用 _ 忽略不需要的 iota
    KB = 1 << (10 * iota)          // 1 << (10*1)
    MB                             // 1 << (10*2)
    GB                             // 1 << (10*3)
    // comments                    // 跳过注释
                                   // 跳过空行
    TB                             // 1 << (10*4)
    PB                             // 1 << (10*5)
    EB                             // 1 << (10*6)
    ZB                             // 1 << (10*7)
    YB                             // 1 << (10*8)
)

// 赋值两个常量，iota 只会增长一次，而不会因为使用了两次就增长两次
const (
    Apple, Banana = iota + 1, iota + 2 // Apple=1 Banana=2
    Cherimoya, Durian                  // Cherimoya=2 Durian=3
    Elderberry, Fig                    // Elderberry=3, Fig=4

)
```

### 复合数据类型

- 如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。

  当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。

  当然，我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。

- Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。

- make & new

  - new(T) 为类型T分配一片内存，**返回一个指向类型为 T，值为 零值 的地址的指针**，它适用于值类型如数组和结构体；它相当于 `&T{}`。
  - make(T) **返回一个类型为 T 的初始值**，它只适用于3种内建的引用类型：切片、map 和 channel。

  1. slice、map以及channel都是golang内建的一种引用类型，三者在内存中存在多个组成部分， 需要对内存组成部分初始化后才能使用，而make就是对三者进行初始化的一种操作方式。

  2. new 获取的是存储指定变量内存地址的一个变量，对于变量内部结构并不会执行相应的初始化操作，只是设置为零值，如int: 0，string: ""，对于结构体则是将结构体内的每个成员设置为零值，内部的结构体同理。而 slice、map、channel 需要make进行初始化并获取对应的内存地址，而非new简单的获取内存地址。

  空切片 & nil切片：[深度解析 Go 语言「切片」的三种特殊状态 零切片、空切片和nil 切片](http://www.meirixz.com/archives/80658.html)

  ```go
  newArr := *new([]int) //能用于append
  newArrPointer := new([]int)
  arr := *newArrPointer // 与newArr性质不一样，不能用于append
  ```

- 数组 & 切片

- `copy` 函数的目标对象需确保其长度（len）与想拷贝的数据一致。

- 结构体匿名成员可以通过简短形式访问匿名成员嵌套的成员。

- 对于能为 `nil` 的类型 `append` 会给分组添加个空对象，若不能为`nil`，则会（编译）报错。

- `append` 方法的参数同样也是值传递。

### 函数

- 虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。

- 注意，不能定义非本地类型（如，内置类型）的方法。

- defer 后跟的必须是函数调用。若其后跟者“多重“函数调用，会先运行前面的，只有”最后一层“函数在程序结束时才调用。

- 注意，在方法里修改方法的接收器变量（如，切片操作）不会影响调用方法的接收器本身。

- go中函数的参数传递采用的是：值传递。

  传递的类型如果是int、string、struct等这些，那在函数中无法修改原参数内容数据；如果是指针、map、slice、chan等这些内置结构的数据时，其实处理的是一个指针类型的数据，在函数中可以修改原参数内容数据。

  参考：[说说不知道的Golang中参数传递 - 腾讯云+社区 - 博客园](https://www.cnblogs.com/qcloud1001/p/10276276.html)

  **slice**数据部分由于是指针类型，在函数内部可以被修改，但len和cap均为int类型。因此函数内部通过append修改了len的数值，但却影响不到函数外部slice的len变量。

  **string**的底层是一个结构体，包括一个指针和一个长度，传参的时候把string的描述结构体复制了一次，所以两个结构体的指针不一样，同时把底层字节数组的指针也复制了，两个字节数组的指针指向同一段区域，也就是字符串字节数组存放的区域，没有发生字符串的整体复制。

  但由于Go中string是immutable，位于只读区强制修改会报`segmentation violation`（除非对于堆中分配的string内容，通过转换为`[]byte`来进行强制修改），所以表现上和值类型没有区别。

### 接口

- 警告：一个包含nil指针的接口不是nil接口，即不能直接通过与`nil`比较的方式判断接口值是否为空。可通过反射判断接口是否为`nil`，如下：

  ```go
  func IsNil(i interface{}) bool {
  	vi := reflect.ValueOf(i)
  	if vi.Kind() == reflect.Ptr {
  		return vi.IsNil()
  	}
  	return i == nil
  }
  ```

- 利用强制类型转换，将空值 nil 转换为 *Student 类型，再转换为 Person 接口，可以确保该 struct 实现了对应接口。

  如果实现不完整，编译期将会报错。

  注意，结构体实现接口时使用的一般是指针对象。
  
  ```go
  var _ Person = (*Student)(nil)
  ```

### 错误处理

- 这是所有自定义包实现者应该遵守的最佳实践：

  1）在包内部，总是应该从 panic 中 recover：不允许显式的超出包范围的 panic()

  2）向包的调用者返回错误值（而不是 panic）。

#### 错误类型体系

构建错误值体系的基本方式有两种：**立体的错误类型体系**和**扁平的错误值列表**。

##### 错误类型体系

参考标准库的`net`代码包，有一个名为`Error`的接口类型。它是内建接口类型`error`的一个扩展接口。

`net`包中有很多错误类型都实现了`net.Error`接口。

这可以看做是一种多层分类的手段。当`net`包的使用者拿到一个错误值的时候，可以先判断它是否是`net.Error`类型的，是否是一个网络相关的错误。

如果是，还可以再进一步判断它的类型是哪一个更具体的错误类型，这样就能知道这个网络相关的错误具体是由于操作不当引起的，还是因为网络地址问题引起的，又或是由于网络协议不正确引起的。

这些错误类型的值之间还可以有另外一种关系，即：链式关系。比如说，使用者调用 `net.DialTCP `之类的函数时，`net `包中的代码可能会返回给他一个 `net.OpError` 类型的错误值，以表示由于他的操作不当造成了一个错误。同时，这些代码还可能会把一个 `*net.AddrError` 或 `net.UnknownNetworkError` 类型的值赋给该错误值的 `Err` 字段，以表明导致这个错误的潜在原因。如果，此处的潜在错误值的 `Err` 字段也有非 `nil` 的值，那么将会指明更深层次的错误原因。如此一级又一级就像链条一样最终会指向问题的根源。

##### 错误值列表

用于想预先创建一些代表已知错误的错误值时候。由于`error`是接口类型，所以通过`errors.New`函数生成的错误值只能被赋给变量，而不能赋给常量，又由于这些代表错误的变量需要给包外代码使用，所以其访问权限只能是公开的。

这就带来了一个问题，如果有恶意代码改变了这些公开变量的值，那么程序的功能就必然会受到影响。

解决方案：

1. 先私有化此类变量，让它们的名称首字母变成小写，然后编写公开的用于获取错误值以及用于判等错误值的函数。

2. `syscall`包中有一个类型叫做`Errno`，该类型代表了系统调用时可能发生的底层错误。这个错误类型是`error`接口的实现类型，同时也是对内建类型`uintptr`的再定义类型。

   由于`uintptr`可以作为常量的类型，所以`syscall.Errno`自然也可以。`syscall`包中声明有大量的`Errno`类型的常量，每个常量都对应一种系统调用错误。`syscall`包外的代码可以拿到这些代表错误的常量，但却无法改变它们。


## 并发

- `ch := make(chan struct{})`

- 箭头`<-`和关键字chan的相对位置表明了channel的方向。

- 并不需要关闭每一个channel。只有当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。）

- 任何双向channel向单向channel变量的赋值操作都将导致该隐式转换。这里并没有反向转换的语法。

- goroutines可能会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。

- 不要使用共享数据来通信；使用通信来共享数据

- go里没有重入锁。也就是说没法对一个已经锁上的mutex来再次上锁——这会导致程序死锁。

  关于Go的mutex不能重入这一点我们有很充分的理由。mutex的目的是确保共享变量在程序执行时的关键点上能够保证不变性。不变性的一层含义是“没有goroutine访问共享变量”，但实际上这里对于mutex保护的变量来说，不变性还包含更深层含义：当一个goroutine获得了一个互斥锁时，它能断定被互斥锁保护的变量正处于不变状态（译注：即没有其他代码块正在读写共享变量），在其获取并保持锁期间，可能会去更新共享变量，这样不变性只是短暂地被破坏，然而当其释放锁之后，锁必须保证共享变量重获不变性并且多个goroutine按顺序访问共享变量。尽管一个可以重入的mutex也可以保证没有其它的goroutine在访问共享变量，但它不具备不变性更深层含义。（译注：[更详细的解释](https://stackoverflow.com/questions/14670979/recursive-locking-in-go/14671462#14671462)，Russ Cox认为可重入锁是bug的温床，是一个失败的设计）
  
- 使用锁的情景：

  - 访问共享数据结构中的缓存信息
  - 保存应用程序上下文和状态信息数据

- 使用通道的情景：

  - 与异步操作的结果进行交互
  - 分发任务
  - 传递数据所有权

## 文件处理

[（十二）Go文件处理_taokexia的博客-CSDN博客_go 文件处理](https://blog.csdn.net/taokexia/article/details/106248135)

## 网络编程

[（十三）Go网络编程_taokexia的博客-CSDN博客](https://blog.csdn.net/taokexia/article/details/106306290)

## 参考

- [gopl-zh](https://github.com/gopl-zh/gopl-zh.github.com)
- [Go入门指南](https://github.com/unknwon/the-way-to-go_ZH_CN)
- [GitHub - unknwon/go-fundamental-programming: 《Go 编程基础》是一套针对 Google 出品的 Go 语言的视频语音教程，主要面向新手级别的学习者。](https://github.com/Unknwon/go-fundamental-programming)
- [实效Go编程 - Go 编程语言](https://go-zh.org/doc/effective_go.html)
- [Go_taokexia的博客-CSDN博客](https://blog.csdn.net/taokexia/category_9940384.html)